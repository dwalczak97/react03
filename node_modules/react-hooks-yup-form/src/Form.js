import React, { useEffect, useState } from "react";
import PropTypes from "prop-types";
import dot from "dot-object";

import FormContext from "./FormContext";
import { yupSchemaType } from "types";

const isObject = function(obj) {
  return obj !== null && typeof obj === "object";
};

const getObjectLength = obj => {
  return isObject(obj) ? Object.keys(obj).length : null;
};

// validate function will be applied if no yup schema provided
// returned object from validate function should follow the schema: {fild_name: error_message, ...}
function Form({ onSubmit, validate, yupSchema, children }) {
  const fieldDefaults = { error: "", touched: false };
  const [fields, setFields] = useState({});
  const [isSubmitting, setSubmitting] = useState(false);
  const [isValidating, setValidating] = useState(false);
  const [isValid, setValid] = useState(false);

  const registerField = (name, field) => {
    if (!isObject(field)) {
      console.log(`Provided field is not an object: ${field}`);
      return;
    }

    setFields(fields => ({
      ...fields,
      [name]: {
        ...fieldDefaults,
        ...field,
        initial: { ...fieldDefaults, ...field }
      }
    }));
  };

  const unregisterField = name => {
    setFields(fields => {
      const newFields = { ...fields };
      delete newFields[name];
      return { ...newFields };
    });
  };

  const handleFieldChange = (fieldName, value) => {
    setFields(fields => ({
      ...fields,
      [fieldName]: { ...fields[fieldName], value }
    }));
  };

  const handleFieldBlur = async (fieldName, value) => {
    setFields(fields => ({
      ...fields,
      [fieldName]: { ...fields[fieldName], touched: true }
    }));

    setValidating(true);
  };

  const touchAllFields = () => {
    const touchFields = fields =>
      Object.keys(fields).reduce((acc, key) => {
        acc[key] = { ...fields[key], touched: true };
        return acc;
      }, {});

    setFields(touchFields);
  };

  const resetForm = () => {
    const discardFields = fields =>
      Object.keys(fields).reduce((acc, key) => {
        acc[key] = fields[key].preserveValuesOnReset
          ? fields[key]
          : {
              ...fields[key].initial,
              initial: fields[key].initial
            };
        return acc;
      }, {});

    setFields(discardFields);
    setValid(false);
    setValidating(true);
  };

  const resetFieldsErrors = (formErrors = {}, fieldErrors = {}) => {
    const combineFieldsErrors = fields =>
      Object.keys(fields).reduce((acc, key) => {
        // on-field validation takes precedence
        const error = fieldErrors[key] || formErrors[key] || "";

        acc[key] = { ...fields[key], error };

        return acc;
      }, {});

    setFields(combineFieldsErrors);
  };

  const handleSubmit = e => {
    e.preventDefault();
    touchAllFields();
    setSubmitting(true);
    setValidating(true);
  };

  const getField = name => {
    return { ...fields[name] };
  };

  useEffect(
    function validatingEffect() {
      if (!isValidating) {
        return;
      }

      validateForm().finally(() => {
        setValidating(false);
      });
    },
    [isValidating]
  );

  useEffect(
    function submittingEffect() {
      if (!isSubmitting) {
        return;
      }

      if (isValidating) {
        return;
      }

      if (!isValid) {
        setSubmitting(false);
        return;
      }

      submitForm().finally(() => {
        setSubmitting(false);
      });
    },
    [isSubmitting, isValidating, isValid]
  );

  const getFieldsValues = () => {
    const plainFieldsValues = Object.keys(fields).reduce((acc, key) => {
      acc[key] = fields[key].value;
      return acc;
    }, {});

    // convert from {'a.b': 5, 'a.c':100} to {a: {b:5, c:100}}
    return dot.object(plainFieldsValues);
  };

  const validateSingleField = fieldName => {
    const { yupSchema, validate, value } = fields[fieldName];

    if (!yupSchema) {
      return validate(value);
    }

    try {
      yupSchema.validateSync(value);
    } catch (e) {
      return e.message;
    }
  };

  const validateEveryField = () => {
    return Object.keys(fields).reduce((acc, key) => {
      const error = validateSingleField(key);

      if (error) {
        acc[key] = error;
      }

      return acc;
    }, {});
  };

  const validateYupSchema = async values => {
    try {
      await yupSchema.validate(values, { abortEarly: false });
    } catch (yupError) {
      return yupError.inner.reduce((acc, error) => {
        acc[error.path] = error.message;
        return acc;
      }, {});
    }
  };

  const validateForm = async () => {
    let formErrors = null;
    let fieldsErrors = null;
    try {
      const values = getFieldsValues();
      formErrors = yupSchema
        ? await validateYupSchema(values)
        : await validate(values);
      fieldsErrors = validateEveryField();
    } catch (e) {
      console.log(`Exception on validation: ${e}`);
    }

    const hasErrors =
      getObjectLength(formErrors) || getObjectLength(fieldsErrors);
    resetFieldsErrors(formErrors, fieldsErrors);
    setValid(!hasErrors);
  };

  const submitForm = async () => {
    await onSubmit(getFieldsValues());
    resetForm();
  };

  return (
    <FormContext.Provider
      value={{
        registerField,
        unregisterField,
        handleFieldChange,
        handleFieldBlur,
        getField,
        isSubmitting,
        isValidating,
        isValid
      }}
    >
      <form onSubmit={handleSubmit}>{children}</form>
    </FormContext.Provider>
  );
}

Form.propTypes = {
  onSubmit: PropTypes.func,
  validate: PropTypes.func,
  yupSchema: yupSchemaType
};

Form.defaultProps = {
  onSubmit: () => {},
  validate: () => {}
};

export default Form;
